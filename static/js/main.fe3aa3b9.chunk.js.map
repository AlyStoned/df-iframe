{"version":3,"sources":["features/file-handler/FileHandler.module.css","utils/exposedAPI.ts","features/file-handler/Iframe.tsx","features/file-handler/FileHandler.tsx","logo.svg","App.tsx","features/file-handler/counterAPI.ts","features/file-handler/counterSlice.ts","app/store.ts","serviceWorker.ts","index.tsx"],"names":["module","exports","ClientExposedAPI","src","iframe","url","api","port","URL","handleInitMessage","bind","init","event","this","eventIsValid","ports","setupApi","Boolean","origin","startsWith","data","status","wrap","fire","window","addEventListener","removeEventListener","releaseProxy","off","name","ready","method","args","Reflect","apply","get","EventEmitter","Iframe","exposedAPI","onAPIReady","props","handleIframeLoad","useCallback","a","current","once","useEffect","destroy","undefined","id","title","width","height","frameBorder","allow","ref","FileHandler","useRef","useState","isIframeOpen","setIframeOpen","fileObjects","setFileObjects","disabled","length","useDropzone","onDropAccepted","acceptedFiles","evt","fileObjs","map","file","uuid","nanoid","exists","multiple","maxFiles","getRootProps","getInputProps","isDragActive","models","transfer","fileObject","className","cn","styles","row","hidden","onClick","uuit","stopPropagation","filter","button","open","onClose","closeOnEsc","center","classNames","modal","popup","App","logo","alt","fetchCount","amount","Promise","resolve","setTimeout","incrementAsync","createAsyncThunk","response","counterSlice","createSlice","initialState","value","reducers","increment","state","decrement","incrementByAmount","action","payload","extraReducers","builder","addCase","pending","fulfilled","actions","store","configureStore","reducer","counter","counterReducer","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.fe3aa3b9.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"row\":\"FileHandler_row__1IqbK\",\"button\":\"FileHandler_button__Allyh\",\"popup\":\"FileHandler_popup__1Tunt\"};","import { Remote, releaseProxy, wrap } from 'comlink';\nimport { EventEmitter } from '@billjs/event-emitter';\nimport { ExcludeConditionally, FilterConditionally } from '../types';\n\nexport interface ExposedAPI {\n    models: {\n        transfer: (files: File[]) => void;\n    };\n    add: (a: number, b: number) => number;\n    test: (a: boolean, c: string) => number;\n    field: number;\n}\n\nexport type ExposedAPIFields = ExcludeConditionally<ExposedAPI, Function>;\nexport type ExposedAPIMethods = FilterConditionally<ExposedAPI, Function>;\n\nexport class ClientExposedAPI extends EventEmitter {\n    public url: URL;\n    public iframe: HTMLIFrameElement;\n    public api?: Remote<ExposedAPI>;\n    private port?: MessagePort;\n\n    constructor(src: string, iframe: HTMLIFrameElement) {\n        super();\n        this.url = new URL(src);\n        this.iframe = iframe;\n\n        this.handleInitMessage = this.handleInitMessage.bind(this);\n        this.init();\n    }\n\n    private handleInitMessage(event: MessageEvent) {\n        if (!this.eventIsValid(event)) return;\n\n        this.port = event.ports[0];\n        this.setupApi(this.port);\n    }\n\n    private eventIsValid(event: MessageEvent) {\n        return Boolean(event.origin.startsWith(this.url.origin) && event.data.status === 'ready' && event.ports[0]);\n    }\n\n    private setupApi(port: MessagePort) {\n        this.api = wrap<ExposedAPI>(port);\n        this.fire('ready', this.api);\n    }\n\n    private init() {\n        // Listen for the initial port transfer message\n        window.addEventListener('message', this.handleInitMessage);\n    }\n\n    public destroy() {\n        // console.log('destroy');\n        window.removeEventListener('message', this.handleInitMessage);\n        this.api && this.api[releaseProxy]();\n        this.fire('destroy');\n        this.off();\n    }\n\n    public async call<T extends keyof ExposedAPIMethods>(name: T, ...args: Parameters<ExposedAPIMethods[T]>) {\n        if (!this.ready) return;\n\n        const method = this.api![name];\n        await Reflect.apply(method, this.api, args);\n        // await method(...args);\n    }\n\n    public async get<T extends keyof ExposedAPIFields>(name: T) {\n        if (!this.ready) return;\n\n        await Reflect.get(this.api!, name);\n    }\n\n    public get ready() {\n        return Boolean(this.port && this.api);\n    }\n}\n","import React, { EmbedHTMLAttributes, MutableRefObject, useEffect, useCallback } from 'react';\nimport { Event } from '@billjs/event-emitter';\nimport { ClientExposedAPI } from '../../utils';\n\ninterface IFrameProps extends EmbedHTMLAttributes<HTMLIFrameElement> {\n    exposedAPI: MutableRefObject<ClientExposedAPI | undefined>;\n    onAPIReady?: (event: Event) => void;\n}\n\nexport function Iframe({ exposedAPI, onAPIReady, src, ...props }: IFrameProps) {\n    let iframe: HTMLIFrameElement | null = null;\n\n    const handleIframeLoad = useCallback(async () => {\n        // console.log('load');\n        exposedAPI.current = new ClientExposedAPI(src!, iframe!);\n        onAPIReady && exposedAPI.current.once('ready', onAPIReady);\n    }, [exposedAPI, onAPIReady, src, iframe]);\n\n    useEffect(() => {\n        if (iframe) {\n            iframe.addEventListener('load', handleIframeLoad, { once: true });\n        }\n\n        return () => {\n            exposedAPI.current?.destroy();\n            exposedAPI.current = undefined;\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [iframe]);\n\n    return (\n        <iframe\n            id=\"df-iframe\"\n            title=\"DF Iframe Example\"\n            width=\"1024\"\n            height=\"720\"\n            frameBorder=\"0\"\n            allow=\"fullscreen\"\n            src={src}\n            ref={ref => {\n                iframe = ref as HTMLIFrameElement;\n            }}\n            {...props}\n        />\n    );\n}\n","import cn from 'classnames';\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\nimport { nanoid } from '@reduxjs/toolkit';\nimport { useDropzone, DropzoneOptions } from 'react-dropzone';\nimport Modal from 'react-responsive-modal';\n\n// import { useAppSelector, useAppDispatch } from '../../app/hooks';\n// import { decrement, increment, selectCount } from './counterSlice';\nimport { ClientExposedAPI } from '../../utils';\nimport { FileObject } from './types';\nimport { Iframe } from './Iframe';\n\nimport styles from './FileHandler.module.css';\n\nconst iframeSrc = 'https://app-test.digifabster.com/4taps/widget/upload';\n// const iframeSrc = 'http://localhost:4200/4taps/widget/cart';\nconst maxFiles = 1;\nconst multiple = maxFiles > 1;\n\nexport function FileHandler() {\n    // const dispatch = useAppDispatch();\n    // const count = useAppSelector(selectCount);\n    const exposedAPI = useRef<ClientExposedAPI>();\n\n    const [isIframeOpen, setIframeOpen] = useState(false);\n\n    const [fileObjects, setFileObjects] = useState<FileObject[]>([]);\n    const disabled = fileObjects.length === maxFiles;\n\n    const handleDropAccepted: DropzoneOptions['onDropAccepted'] = (acceptedFiles, evt) => {\n        const fileObjs = acceptedFiles.map(file => {\n            return {\n                uuid: nanoid(),\n                file,\n            };\n        });\n\n        // Notify added files\n        setFileObjects(exists => {\n            // Handle a single file\n            if (maxFiles <= 1) {\n                return [fileObjs[0]];\n            }\n\n            // Handle multiple files\n            return exists.concat(fileObjs);\n        });\n    };\n\n    const handleRemove = (uuit: string) => (event: MouseEvent) => {\n        event.stopPropagation(); // case into dropzone\n\n        // Update local state\n        setFileObjects(exists => exists.filter(fileObject => fileObject.uuid !== uuit));\n    };\n\n    const { getRootProps, getInputProps, isDragActive } = useDropzone({\n        // onDrop,\n        onDropAccepted: handleDropAccepted,\n        multiple,\n        disabled,\n        maxFiles,\n    });\n\n    const onAPIReady = useCallback(\n        async event => {\n            if (fileObjects.length) {\n                // console.log('onAPIReady', fileObjects);\n                await event.data.models.transfer(fileObjects.map(fileObject => fileObject.file));\n\n                // reset dropzone files\n                setFileObjects([]);\n            }\n\n            // console.log('result 1 + 3 = ', await event.data.add(1, 3));\n            // console.log('field = ', await event.data.field);\n            // console.log('test', exposedAPI.current && exposedAPI.current.call('test', false, '343'));\n            // exposedAPI.current && exposedAPI.current.call('add', 3, 6);\n            // exposedAPI.current && exposedAPI.current.api?.add(3, 6);\n        },\n        [fileObjects],\n    );\n\n    return (\n        <div>\n            <div className={cn(styles.row, { hidden: disabled })}>\n                <div {...getRootProps()}>\n                    <input {...getInputProps()} />\n                    <p>Drop file here, or click to select file</p>\n                </div>\n            </div>\n            <div className={cn(styles.row, { hidden: !disabled })}>\n                {fileObjects.map(fileObject => (\n                    <button\n                        key={fileObject.uuid}\n                        title=\"Click to remove\"\n                        // @ts-ignore\n                        onClick={handleRemove(fileObject.uuid)}\n                    >\n                        {fileObject.file.name}\n                    </button>\n                ))}\n            </div>\n\n            <div className={styles.row}>\n                <button className={styles.button} onClick={() => setIframeOpen(true)}>\n                    Open Iframe\n                </button>\n            </div>\n\n            <Modal\n                open={isIframeOpen}\n                onClose={() => setIframeOpen(false)}\n                closeOnEsc={true}\n                center={true}\n                classNames={{\n                    modal: styles.popup,\n                }}\n            >\n                <Iframe exposedAPI={exposedAPI} onAPIReady={onAPIReady} src={iframeSrc} />\n            </Modal>\n        </div>\n    );\n}\n","export default __webpack_public_path__ + \"static/media/logo.183d3140.svg\";","import React from 'react';\nimport { FileHandler } from './features/file-handler/FileHandler';\nimport logo from './logo.svg';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <FileHandler />\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","// A mock function to mimic making an async request for data\nexport function fetchCount(amount = 1) {\n  return new Promise<{ data: number }>((resolve) =>\n    setTimeout(() => resolve({ data: amount }), 500)\n  );\n}\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { RootState, AppThunk } from '../../app/store';\nimport { fetchCount } from './counterAPI';\n\nexport interface CounterState {\n  value: number;\n  status: 'idle' | 'loading' | 'failed';\n}\n\nconst initialState: CounterState = {\n  value: 0,\n  status: 'idle',\n};\n\n// The function below is called a thunk and allows us to perform async logic. It\n// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This\n// will call the thunk with the `dispatch` function as the first argument. Async\n// code can then be executed and other actions can be dispatched. Thunks are\n// typically used to make async requests.\nexport const incrementAsync = createAsyncThunk(\n  'counter/fetchCount',\n  async (amount: number) => {\n    const response = await fetchCount(amount);\n    // The value we return becomes the `fulfilled` action payload\n    return response.data;\n  }\n);\n\nexport const counterSlice = createSlice({\n  name: 'counter',\n  initialState,\n  // The `reducers` field lets us define reducers and generate associated actions\n  reducers: {\n    increment: (state) => {\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\n      // doesn't actually mutate the state because it uses the Immer library,\n      // which detects changes to a \"draft state\" and produces a brand new\n      // immutable state based off those changes\n      state.value += 1;\n    },\n    decrement: (state) => {\n      state.value -= 1;\n    },\n    // Use the PayloadAction type to declare the contents of `action.payload`\n    incrementByAmount: (state, action: PayloadAction<number>) => {\n      state.value += action.payload;\n    },\n  },\n  // The `extraReducers` field lets the slice handle actions defined elsewhere,\n  // including actions generated by createAsyncThunk or in other slices.\n  extraReducers: (builder) => {\n    builder\n      .addCase(incrementAsync.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(incrementAsync.fulfilled, (state, action) => {\n        state.status = 'idle';\n        state.value += action.payload;\n      });\n  },\n});\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\n\n// The function below is called a selector and allows us to select a value from\n// the state. Selectors can also be defined inline where they're used instead of\n// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`\nexport const selectCount = (state: RootState) => state.counter.value;\n\n// We can also write thunks by hand, which may contain both sync and async logic.\n// Here's an example of conditionally dispatching actions based on current state.\nexport const incrementIfOdd = (amount: number): AppThunk => (\n  dispatch,\n  getState\n) => {\n  const currentValue = selectCount(getState());\n  if (currentValue % 2 === 1) {\n    dispatch(incrementByAmount(amount));\n  }\n};\n\nexport default counterSlice.reducer;\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport counterReducer, { incrementByAmount } from '../features/file-handler/counterSlice';\n\nexport const store = configureStore({\n    reducer: {\n        counter: counterReducer,\n    },\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<ReturnType, RootState, unknown, Action<string>>;\n\n// window.addEventListener('message', event => {\n//     console.log(event);\n//     console.log(event.data);\n//     // IMPORTANT: check the origin of the data!\n//     if (event.origin.startsWith('http://127.0.0.1:3001')) {\n//     // if (event.origin.startsWith('http://your-first-site.com')) {\n//         // The data was sent from your site.\n//         // Data sent with postMessage is stored in event.data:\n//         console.log(store);\n//         store.dispatch(incrementByAmount(event.data))\n//     } else {\n//         // The data was NOT sent from your site!\n//         // Be careful! Do not use it. This else branch is\n//         // here just for clarity, you usually shouldn't need it.\n//         return;\n//     }\n// });\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nimport 'react-responsive-modal/styles.css';\nimport './index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}